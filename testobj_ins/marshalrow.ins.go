// Code generated by inspc. DO NOT EDIT.
// source: github.com/koykov/dyntpl/testobj

package testobj_ins

import (
	"github.com/koykov/dyntpl/testobj"
	"github.com/koykov/inspector"
	"strconv"
)

type MarshalRowInspector struct {
	inspector.BaseInspector
}

func (i3 *MarshalRowInspector) Get(src interface{}, path ...string) (interface{}, error) {
	var buf interface{}
	err := i3.GetTo(src, &buf, path...)
	return buf, err
}

func (i3 *MarshalRowInspector) GetTo(src interface{}, buf *interface{}, path ...string) (err error) {
	if src == nil {
		return
	}
	var x *testobj.MarshalRow
	_ = x
	if p, ok := src.(**testobj.MarshalRow); ok {
		x = *p
	} else if p, ok := src.(*testobj.MarshalRow); ok {
		x = p
	} else if v, ok := src.(testobj.MarshalRow); ok {
		x = &v
	} else {
		return
	}
	if len(path) == 0 {
		*buf = &(*x)
		return
	}

	if len(path) > 0 {
		if path[0] == "Msg" {
			*buf = &x.Msg
			return
		}
		if path[0] == "N" {
			*buf = &x.N
			return
		}
	}
	*buf = &(*x)
	return
}

func (i3 *MarshalRowInspector) Cmp(src interface{}, cond inspector.Op, right string, result *bool, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.MarshalRow
	_ = x
	if p, ok := src.(**testobj.MarshalRow); ok {
		x = *p
	} else if p, ok := src.(*testobj.MarshalRow); ok {
		x = p
	} else if v, ok := src.(testobj.MarshalRow); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "Msg" {
			var rightExact string
			rightExact = right

			switch cond {
			case inspector.OpEq:
				*result = x.Msg == rightExact
			case inspector.OpNq:
				*result = x.Msg != rightExact
			case inspector.OpGt:
				*result = x.Msg > rightExact
			case inspector.OpGtq:
				*result = x.Msg >= rightExact
			case inspector.OpLt:
				*result = x.Msg < rightExact
			case inspector.OpLtq:
				*result = x.Msg <= rightExact
			}
			return
		}
		if path[0] == "N" {
			var rightExact int
			t17, err17 := strconv.ParseInt(right, 0, 0)
			if err17 != nil {
				return err17
			}
			rightExact = int(t17)
			switch cond {
			case inspector.OpEq:
				*result = x.N == rightExact
			case inspector.OpNq:
				*result = x.N != rightExact
			case inspector.OpGt:
				*result = x.N > rightExact
			case inspector.OpGtq:
				*result = x.N >= rightExact
			case inspector.OpLt:
				*result = x.N < rightExact
			case inspector.OpLtq:
				*result = x.N <= rightExact
			}
			return
		}
	}
	return
}

func (i3 *MarshalRowInspector) Loop(src interface{}, l inspector.Looper, buf *[]byte, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.MarshalRow
	_ = x
	if p, ok := src.(**testobj.MarshalRow); ok {
		x = *p
	} else if p, ok := src.(*testobj.MarshalRow); ok {
		x = p
	} else if v, ok := src.(testobj.MarshalRow); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
	}
	return
}

func (i3 *MarshalRowInspector) SetWB(dst, value interface{}, buf inspector.AccumulativeBuffer, path ...string) error {
	if len(path) == 0 {
		return nil
	}
	if dst == nil {
		return nil
	}
	var x *testobj.MarshalRow
	_ = x
	if p, ok := dst.(**testobj.MarshalRow); ok {
		x = *p
	} else if p, ok := dst.(*testobj.MarshalRow); ok {
		x = p
	} else if v, ok := dst.(testobj.MarshalRow); ok {
		x = &v
	} else {
		return nil
	}

	if len(path) > 0 {
		if path[0] == "Msg" {
			inspector.AssignBuf(&x.Msg, value, buf)
			return nil
		}
		if path[0] == "N" {
			inspector.AssignBuf(&x.N, value, buf)
			return nil
		}
	}
	return nil
}

func (i3 *MarshalRowInspector) Set(dst, value interface{}, path ...string) error {
	return i3.SetWB(dst, value, nil, path...)
}
