# Dynamic templates

Динамическая замена шаблонизатора [quicktemplate](https://github.com/valyala/quicktemplate).

## Ретроспектива

Мы долгое время использовали quicktemplate при создании JSON документов для обмена данными между микросервисами в
высоконагруженном проекте и qtpl обеспечивал очень хорошую скорость работы. Далее появилась необходимость менять
шаблоны (или создавать новые) на лету. К сожалению, qtpl не поддерживает такую возможность и эта библиотека была
разработана как замена со сравнимой скоростью и динамическими возможностями. Соответственно она во многом следует
синтаксису qtpl.

## Принцип работы

Работа с шаблонами поделена на два этапа - парсинг и шаблонизация. Первый этап строит на основе шаблона специальное
дерево (аналог AST), которое затем надо зарегистрировать в регистре шаблонов под каким-то уникальным именем. Этот этап
не предназначен для слишком частого исполнения, т.к. он тяжёлый и дорогой. Второй этап - шаблонизация, напротив предназначен
для использования в хайлоаде. Чтобы передать данные для шаблонизации необходимо добавить переменные в специальную структуру
[Ctx](ctx.go). Каждая переменная характеризуется тремя параметрами:
* уникальное имя
* данные - всё что угодно, что вам необходимо на этапе шаблонизации
* тип-инспектор

Тип инспектор надо рассмотреть подробнее.

В процессе разработки наибольшей проблемой стало получение данных из произвольных структур без использования рефлексии,
поскольку пакет `reflect` слишком медленный и делает много аллоков при любом использовании типа `reflect.Value`.

Для решения этой проблемы был разработан кодогенерирующий фреймворк [inspector](https://github.com/koykov/inspector/blob/master/readme.ru.md).
Он предоставляет примитивные методы для чтения данных из структур, итерирования и тд. без использования рефлексии, причём
делает это быстро. Это достигается посредством использования кодогенерации - inspector для каждой указанной структуры
(или пакета целиком) генерирует специальные типы, содержащие код специфичный для конкретной структуры. Это не чистая
динамика какую предоставляет пакет `reflect`, но зато работает на порядки [быстрее](https://github.com/koykov/versus/tree/master/inspector2)
и не делает аллокаций.

Пример работы кодогенератора можно посмотреть в пакете [testobj_ins](./testobj_ins), который был сгенерирован на основе
пакета [testobj](./testobj).

## Пример использования

```go
package main

import (
	"bytes"

	"github.com/koykov/dyntpl"
	"path/to/inspector_lib_ins"
	"path/to/test_struct"
)

var (
	// Fill up test struct with data.
	data = &test_struct.Data{
		// ...
	}

	// Template code.
	tplData = []byte(`{"id":"{%=data.Id%}","hist":[{%for _,v:=range data.History separator ,%}"{%=v.Datetime%}"{%endfor%}]}`)
)

func init() {
	// Parse the template and register it.
	tree, _ := dyntpl.Parse(tplData, false)
	dyntpl.RegisterTplKey("tplData", tree)
}

func main() {
	// Prepare output buffer
	buf := bytes.Buffer{}
	// Prepare dyntpl context.
	ctx := dyntpl.AcquireCtx()
	ctx.Set("data", data, inspector_lib_ins.DataInspector{})
	// Execute the template and write result to buf.
	_ = dyntpl.Write(&buf, "tplData", ctx)
	// Release context.
	dyntpl.ReleaseCtx(ctx)
	// buf.Bytes() or buf.String() contains the result.
}
```

Содержимое функции `init` должно выполняться один раз (или периодически, на лету, с обновлением шаблона из какого-то
источника, например БД).

Содержимое функции `main` это пример использования dyntpl в хайлоаде.

## Бенчмарки

См. [bench.md](bench.md) с результатами внутренних бенчмарков. Рекомендуется просмотреть `_test.go` файлы в проекте, они
дадут более полное понимание синтаксиса шаблонизатора.

Также доступен [versus/dyntpl](https://github.com/koykov/versus/tree/master/dyntpl) проект со сравнительными бенчмарками
между dyntpl, quicktemplates и нативным шаблонизатором. Как можно увидеть, qtpl в несколько раз быстрее dyntpl, что
неудивительно, т.к. qtpl шаблоны компилируются в нативный Go код. Такова цена наличия динамичности в шаблонизаторе.

## Синтаксис

Как уже упоминалось выше, dyntpl наследует синтаксис у qtpl, но дополнительно имеет множество своих особенностей и
улучшений.

### Вывод данных

Самая базовая инструкция - вывод значения переменной или поля структуры:
```
Это значение обычной переменной: {%= var0 %}
Это значения поля структуры: {%= obj.Parent.Name %}
```
Инструкция `{%= ... %}` выведет значение как есть, без учёта типа, экранирования и модификаций.

Для типобезопасного вывода существуют специальные экранирующие модификаторы. Их надо указывать до инструкции вывода `=`:
* `h` - экранирование HTML.
* `a` - экранирование HTML аттрибута.
* `j` - экранирование JSON.
* `q` - цитирование JSON (quote).
* `J` - экранирование JS (JavaScript).
* `u` - кодирование URL.
* `l` - экранирование ссылок.
* `c` - экранирование CSS.
* `f.<num>` - округление float до количества знаков после запятой, пример: `{%f.3= 3.1415 %}` выведет `3.141`.
* `F.<num>` - округление вверх float до количества знаков после запятой, пример: `{%F.3= 3.1415 %}` выведет `3.142`.

Замечу, что эти модификаторы не применяются по умолчанию и обязанностью пользователя является их оценка необходимости
и применение в нужных местах шаблона.

Все модификаторы (кроме `f` и `F`) допускают множественное использование - `{%jj= ... %}`, `{%uu= ... %}`, `{%uuu= ... %}`, ...

Например, такая инструкция `{%uu= someUrl %}` выведет дважды экранированное значение `someUrl`. Это может быть полезным
для построения цепочек редиректов:
```
https://domain.com?redirect0={%u= url0 %}{%uu= url1 %}{%uuu= url2 %}
```

Также модификаторы вывода можно комбинировать друг с другом в любых комбинациях (`{%Ja= var1 %}`, `{%jachh= var1 %}`, ...).
Модификаторы будут применяться последовательно и каждый следующий модификатор получит на вход результат работы предыдущего.

#### Bound теги

Если необходимо применить экранирование сразу к большому блоку, содержащему как текст, так и вывод переменных, то для
этих целей разработаны специальные bound теги:
* `{% jsonquote %}...{% endjsonquote %}` применяет JSON экранирование ко всему содержимому.
* `{% htmlescape %}...{% endhtmlescape %}` применяет HTML экранирование.
* `{% urlencode %}...{% endurlencode %}` применяет URL encode.

Пример:
```
{"key": "{% jsonquote %}Lorem ipsum "dolor sit amet", {%= var0 %}.{%endjsonquote%}"}
```

#### Префикс/суффикс

Инструкция вывода позволяет указать префикс и/или суффикс (пример `{%= var0 prefix foo suffix bar %}`). Префикс/суффикс
будет выведен только если выводимое значение не пустое. Также доступны сокращённые варианты `pfx` и `sfx`.

### Модификаторы вывода

Помимо уже упомянутых выше коротких модификаторов, указываемых до `=`, существуют также пользовательские модификаторы
вывода. Указываются уже после выводимой переменной через символ `|` и выглядят как вызов функции. Примеры:
```
Name: {%= obj.Name|default("anonymous") %}Welcome, {%= testNameOf(user, {"foo": "bar", "id": user.Id}, "qwe") %}
Chain of modifiers: {%= dateVariable|default("2022-10-04")|formatDate("%y-%m-%d") %}
Welcome, {%= testNameOf(user, {"foo": "bar", "id": user.Id}, "qwe") %}
             ^
             no variable here, therefore null provided to modifier
```

Модификаторы можно объединять в цепочки произвольной длины. В этом случае на вход каждого модификатора будет подаваться
результат работы предыдущего. Также, в каждый из модификаторов можно передавать произвольное количество параметров.

С точки зрения API, модификатор это Go функция со специальной сигнатурой:
```go
type ModFn func(ctx *Ctx, buf *any, val any, args []any) error
```
, где:
* ctx - полный контекст шаблона
* buf - указатель для возврата значения из модификатора
* val - значение передаваемое в модификатор (в примере `varName|modifier()` это значение переменной `varName`)
* args - список всех параметров, переданных в модификатор

Написав свой пользовательский модификатор, следует зарегистрировать его с помощью одной из функций:
* `RegisterModFn(name, alias string, mod ModFn)`
* `RegisterModFnNS(namespace, name, alias string, mod ModFn)`

Функции одинаковы, но NS-версия позволяет указать пространство имён, где будет находиться ваш модификатор. В таком случае
обращаться к нему надо будет с указанием namespace:
```
Print using ns: {%= varName|namespaceName::modifier() %}
```

Также можно указать псевдоним (alias) имени модификатора, чтобы к нему можно было обращаться с альтернативным именем.
Как правило, алиасы предназначены для указания сокращённого имени модификатора:
```go
RegisterModFn("default", "def", modDefault)
//                       ^
//                       shorthand alias
```

### Условия

Синтаксис условных операторов классический, за вычетом фигурных скобок:
```
{% if leftVar [==|!=|>|>=|<|<=] rightVar %}
    true branch
{% else %}
    false branch
{% endif %}
```

Примеры: [1](testdata/parser/condition.tpl), [2](testdata/parser/conditionNested.tpl), [3](testdata/parser/conditionStr.tpl).

dyntpl не способен распарсить сложные условия, содержащие более одной проверки, пример:
```
{% if user.Id == 0 || user.Finance.Balance == 0 %}You're not able to buy!{% endif %}
```
В будущем эта проблема будет решена, а пока можно сделать несколько вложенных проверок или воспользоваться механизмом
`condition helpers` - это функции со специальной сигнатурой
```go
type CondFn func(ctx *Ctx, args []any) bool
```
, куда можно передать произвольное количество параметров и код этих функций вернёт bool, согласно которому будет выбрана
ветка для исполнения. Эти функции пользовательские и вы можете создать свою и затем зарегистрировать её с помощью функций
```go
func RegisterCondFn(name string, cond CondFn)
func RegisterCondFnNS(namespace, name string, cond CondFn) // namespace version
```

Принцип такой же как у пользовательских модификаторов. Далее condition helper станет доступен в шаблонах по указанному имени:
```
{% if helperName(user.Id, user.Finance.Balance) %}You're not able to buy!{% endif %}
```

В виде отдельного исключения существуют функции `len()` и `cap()`, которые работают аналогично нативным функциям Go.
Результат их выполнения можно сравнивать
```
{% if len(user.Name) > 0 %}...{% endif %}
```
, тогда как обычные пользовательские функции не допускают никакие сравнения.

Для цепочки сравнений dyntpl поддерживает switch оператор, примеры:
* [классический switch](testdata/parser/switch.tpl)
* [switch без условия](testdata/parser/switchNoCondition.tpl)
* [switch без условия и с helper-ми](testdata/parser/switchNoConditionWithHelper.tpl)

switch имеет те же самые ограничения для условий, что и обычное условие. Поэтому необходимо заменять сложные условия
helper-ми.

### Циклы

dyntpl поддерживает оба типа циклов, как и Go:
* циклы со счётчиком, пример `{% for i:=0; i<5; i++ %}...{% endfor %}`
* range-циклы, пример `{% for k, v := range obj.Items %}...{% endfor %}`

Пограничные случаи, такие как `for k < 2000 {...}` или `for ; i < 10 ; {...}` не поддерживаются.

#### Разделители

Если нужно между итерациями вывести какой-то разделитель, то dyntpl поддерживает для циклов специальную инструкцию
`separator`, которая явно указывает, что нужно выводить:
```
[
  {% for _, a := range user.History separator , %}
    {
      "id": {%q= a.Id %},
      "date": {%q= a.Date %},
      "comment": {%q= a.Note %}
    }
  {% endfor %}
]
```

Этот шаблон будет иметь такой вывод:
```json
[
  {"id":1, "date": "2020-01-01", "comment": "success"},
  {"id":2, "date": "2020-01-01", "comment": "failed"},
  {"id":3, "date": "2020-01-01", "comment": "rejected"}
]
```

Разделитель `,` будет выведен в начале каждой итерации (кроме первой) без ручного управления вида `...{% if i>0 %},{% endif %}{% endfor %}`.
Также доступен короткий вариант `sep` вместо `separator`.

#### loop-else

Разделитель не является единственной эксклюзивной особенностью циклов в dyntpl. Также для циклов доступна `else` инструкция:
```
<select name="type">
  {% for k, v := range user.historyTags %}
    <option value="{%= k %}">{%= v %}</option>
  {% else %}
    <option>N/D</option>
  {% endfor %}
</select>
```
, что позволяет обрабатывать случаи, когда нечего итерировать, без использования ручных проверок. В примере выше, если
источник `user.historyTags` будет пустым, то будет выведен пустой option.

#### Прерывание циклов

dyntpl поддерживает стандартные инструкции `break` и `continue`, для прерывания циклов/итераций, пример:
```
{% for _, v := list %}
  {% if v.ID == 0 %}
    {% continue %}
  {% endif %}
  {% if v.Status == -1 %}
    {% break %}
  {% endif %}
{% endfor %}
```

Эти инструкции работают стандартно и предсказуемо, но всё же являются громоздкими, поэтому были разработаны удобные
условные инструкции `break if` и `continue if`, которые работают аналогично:
```
{% for _, v := list %}
  {% continue if v.ID == 0 %}
  {% break if v.Status == -1 %}
{% endfor %}
```

Оба примера идентичны друг другу, просто второй записан более компактно.

Это не единственный эксклюзив в прерывании циклов. Представим себе ситуацию, что во время итерации стало понятным, что
её необходимо прервать, но также необходимо довести текущую итерацию до конца. Например выводится какой-то xml элемент
и если прервать итерацию, то мы получим незакрытый тег:
```
<?xml version="1.0" encoding="UTF-8"?>
<users>
  {% for _, u := range users %}
    <user>
        <name>{%= u.Name %}</name>
        {% if u.Blocked == 1 %}
          {% break %} {# <-- unclosed tag reson #}
        {% endif %}
        <balance>{%= u.Balance }</balance>
    </user>
  {% endfor %}
</users>
```

Очевидно, в итоге мы получим невалидный XML документ. Специально для таких случаев была разработана инструкция `lazybreak`.
Она прерывает цикл, но позволяет текущей итерации доработать до конца.

В нативном Go для прерывания двух вложенных циклов необходимо использовать один из операторов:
* `goto <label>`  
* `break <label>`  
* `continue <label>`  

, что явно избыточно для шаблонизатора. Намного более удобным способом является вариант
[break, предоставляемый языком php](https://www.php.net/manual/en/control-structures.break.php).
Он позволяет указать после ключевого слова количество вложенных циклов, которые необходимо прервать. В dyntpl была
реализована именно эта идея и сейчас доступны операторы:
* `break N`
* `lazybreak N`

Пример:
```
{% for i:=0; i<10; i++ %}
  bar
  {% for j:=0; i<10; i++ %}
    foo
    {% if j == 8 %}
      {% break 2 %}
    {% endif %}
    {% if j == 7 %}
      {% lazybreak 2 %}
    {% endif %}
    {%= j %}
  {% endfor %}
  {%= i %}
{% endfor %}
```

Для `break/lazybreak N` инструкций также доступны условные версии:
* `break N if`
* `lazybreak N if`

Например пример выше можно записать так:
```
    ...
    {% break 2 if j == 8 %}
    {% lazybreak 2 if j == 7 %}
    ...
```
и получить аналогичный результат.

### Расширения

Возможности dyntpl могут быть расширены посредством включения в проект модулей расширения. Это обычные пакеты Go,
в которых вызываются функции регистрации модификаторов (`RegisterModFn`, `RegisterModFnNS`) или регистрация
условных helper-ов (`RegisterCondFn`, `RegisterCondFnNS`) или прочие функции регистрации из dyntpl API. В итоге
в шаблонах появляются новые модификаторы и прочие вспомогательные функции.

В данный момент поддерживаются следующие расширения:
* [dyntpl_vector](https://github.com/koykov/dyntpl_vector) предоставляет возможность использовать функционал векторных парсеров в шаблонах.
* [dyntpl_i18n](https://github.com/koykov/dyntpl_i18n) предоставляет возможность использования i18n функций для перевода внутри шаблонов.

Для подключения модуля расширения его нужно принудительно импортировать, например так:
```go
import (
	_ "https://github.com/koykov/dyntpl_vector"
)
```
и в шаблонах станут доступны все возможности векторных парсеров.

Не стесняйтесь разрабатывать собственные модули расширения. В этом случае рекомендуется регистрировать их в собственном
пространстве имён, как [здесь](https://github.com/koykov/dyntpl_vector/blob/master/init.go#L12).

### Заключение

Из-за наличия двух этапов (парсинг-регистрация и шаблонизация) dyntpl не слишком удобно использовать для простых случаев,
где нет проблем с производительностью. Но в условиях хайлоада и при необходимости динамичности dyntpl показывается себя
хорошо. Как и любой другой инструмент его необходимо использовать с умом и в тех областях, для которых он предназначен.
