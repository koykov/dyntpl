# Dynamic templates

Динамическая замена шаблонизатора [quicktemplate](https://github.com/valyala/quicktemplate).

## Ретроспетива

Мы долгое время использовали quicktemplate для создания JSON докементов для обмена данными между микросервисами в
высоконагруженном проекте и qtpl обеспечивал очень хорошую скорость работы. Далее появилась необходимость менять
шаблоны (или создавать новые) на лету. К сожалению, qtpl не поддерживает такую возможность и эта библиотека была
разработана как замена со сравнимой скоростью и динамическими возможностями. Соотвественно она во многом она следует
синтаксису qtpl.

## Принцип работы

Работа с шаблонами поделена на два этапа - парсинг и шаблонизация. Первый этап строит на основе шаблона специальное
дерево (аналог AST), которое затем надо зарегестрировать в регистре шаблонов под каким-то уникальным именем. Этот этап
не предназначен для слишком частого исполнения, т.к. он тяжёлый и дорогой. Второй этап - шаблонизация, напротив предназначен
для использования в хайлоаде. Чтобы передать данные для шаблонизации необходимо добавить переменные в специальную структуру
[Ctx](ctx.go). Каждая переменная характеризуется тремя параметрами:
* уникальное имя
* данные - всё что угодно, что вам необходимо на этапе шаблонизации
* тип-инспектор

Тип инспектор надо рассмотреть подробнее.

В процессе разработки наибольшей проблемой стало получение данных из произвольных структур без использования рефлексии,
поскольку пакет `reflect` слишком медленный и делает много аллоков при любом использовании типа `reflect.Value`.

Для решения этой проблемы был разработан кодогенерирующий фреймворк [inspector](https://github.com/koykov/inspector/blob/master/readme.ru.md).
Он предоставляет примитивные методы для чтения данных из структур, итерирования и тд. без использования рефлексии, причём
делает это быстро. Это достигается посредством использования кодогенерации - inspector для каждой указанной структуры
(или пакета целиком) делает специальные типы, содержащие код специфичный для конкретной структуры. Это не чистая динамика
какую предоставляет пакет `reflect`, но за то работает на порядки [быстрее](https://github.com/koykov/versus/tree/master/inspector2)
и не делает аллокаций.

Пример работы кодогенерации можно посмотреть в пакете [testobj_ins](./testobj_ins), который был сгенерирован на основе
пакета [testobj](./testobj).

## Пример использования

```go
package main

import (
	"bytes"

	"github.com/koykov/dyntpl"
	"path/to/inspector_lib_ins"
	"path/to/test_struct"
)

var (
	// Fill up test struct with data.
	data = &test_struct.Data{
		// ...
	}

	// Template code.
	tplData = []byte(`{"id":"{%=data.Id%}","hist":[{%for _,v:=range data.History separator ,%}"{%=v.Datetime%}"{%endfor%}]}`)
)

func init() {
	// Parse the template and register it.
	tree, _ := dyntpl.Parse(tplData, false)
	dyntpl.RegisterTplKey("tplData", tree)
}

func main() {
	// Prepare output buffer
	buf := bytes.Buffer{}
	// Prepare dyntpl context.
	ctx := dyntpl.AcquireCtx()
	ctx.Set("data", data, inspector_lib_ins.DataInspector{})
	// Execute the template and write result to buf.
	_ = dyntpl.Write(&buf, "tplData", ctx)
	// Release context.
	dyntpl.ReleaseCtx(ctx)
	// buf.Bytes() or buf.String() contains the result.
}
```

Содержимое функции `init` должно выполняться один раз (или периодически, на лету, с обновлением шаблона из какого-то
источника, например БД).

Содержимое функции `main` это пример использования dyntpl в хайлоаде.

## Бенчмарки

См. [bench.md](bench.md) с результатами внутренних бенчмарков. Рекомендуется просмотреть `_test.go` файлы в проекте, они
датут более полное понимание синтаксиса шаблонизатора.

Также доступен [versus/dyntpl](https://github.com/koykov/versus/tree/master/dyntpl) проект со сравнительными бенчмарками
между dyntpl, quicktemplates и нативным шаблонизатором. Как можно увидеть, qtpl в несколько раз быстрее dyntpl, что
неудивительно, т.к. qtpl шаблоны компилируются в нативный Go код. Такова цена наличия динамичности в шаблонизаторе.

## Синтаксис

Как уже упочиналось выше, dyntpl наследует синтаксис у qtpl, но дополнительно имеет множество своих особенностей и
улучшений.

### Вывод данных

Самая базовая инструкция - вывод занчения переменной или поля структуры:
```
Это значение обычной переменной: {%= var0 %}
Это значения поля структуры: {%= obj.Parent.Name %}
```
Инструкция `{%= ... %}` выведет значение как есть, без учёта типа и модификаций.

Для типобезопасного вывода сущуствуют специальные модификаторы. Их надо указывать до инструкции вывода `=`:
* `h` - экранирование HTML.
* `a` - экранирование HTML аттрибута.
* `j` - экранирование JSON.
* `q` - цитирование JSON (quote).
* `J` - экранирование JS (JavaScript).
* `u` - кодирование URL.
* `l` - экранирование ссылок.
* `c` - экранирование CSS.
* `f.<num>` - округление float до количества знаков после запятой, пример: `{%f.3= 3.1415 %}` выведет `3.141`.
* `F.<num>` - округление вверх float до количества знаков после запятой, пример: `{%F.3= 3.1415 %}` выведет `3.142`.

Замечу, что эти модификаторы не применяются по умолчанию и обязанностью пользователя является их оценка и применение в
нужных местах шаблона.

Все модификаторы (кроме `f` и `F`) допускают множественное использование - `{%jj= ... %}`, `{%uu= ... %}`, `{%uuu= ... %}`, ...

Например, такая инструкция `{%uu= someUrl %}` выведет дважды экранированное значение `someUrl`.

Также модификаторы вывода можно комбинировать друг с другов в любых комбинациях (`{%Ja= var1 %}`, `{%jachh= var1 %}`, ...).
Модификаторы будут применять последовательно и каждый следующий модификатор получит на вход результат работы предыдущего.

Инструкция вывода позволяет указать префикс и/или суффикс (пример `{%= var0 prefix foo suffix bar %}`). Префикс/суффикс
будет выведен только если выводимое значение не пустое. Также доступны сокращённые варианты `pfx` и `sfx`.

### Модификаторы вывода

Помимо уже упомянутых выше коротких модификаторов, указываемых до `=`, существуют также пользовательские модификаторы
вывода. Указываются уже после выводимой переменной через символ `|` и выглядят как вызов функции. Примеры:
```
Name: {%= obj.Name|default("anonymous") %}Welcome, {%= testNameOf(user, {"foo": "bar", "id": user.Id}, "qwe") %}
Chain of modifiers: {%= dateVariable|default("2022-10-04")|formatDate("%y-%m-%d") %}
Welcome, {%= testNameOf(user, {"foo": "bar", "id": user.Id}, "qwe") %}
             ^
             no variable here, therefore null provided to modifier
```

Модификаторы можно объединять в цепочки произвольной длины. Также, в каждый из модификаторов можно передавать
произвольное количество параметров.

С точки зрения API, модификатор это Go функция со специальной сигнатурой:
```go
type ModFn func(ctx *Ctx, buf *any, val any, args []any) error
```
, где:
* ctx - полный контекст шаблона
* buf - указатель для возврата значения из модицикатора
* val - значение передаваемое в модификатор (в примере `varName|modifier()` это значение переменной `varName`)
* args - список всех параметров, переданных в модификатор

Написав свой пользовательский модификатор, следует зарегестрировать его с помощью одной из функций:
* `RegisterModFn(name, alias string, mod ModFn)`
* `RegisterModFnNS(namespace, name, alias string, mod ModFn)`

Функции одинаковы, но NS-версия позволяет указать пространство имён, где будет находиться ваш модификатор. В таком случае
обращаться к нему надо будет с указанием namespace:
```
Print using ns: {%= varName|namespaceName::modifier() %}
```

Также можно указать псевдоним (alias) имени модификатора, чтобы к нему можно было обращаться с альтернативным именем.
Как правило, алиасы предназначены для указания сокращённого имени модификатора:
```go
RegisterModFn("default", "def", modDefault)
//                       ^
//                       shorthand alias
```

### Условия

Сантаксис условных операторов классический, за вычетом фигурных скобок:
```
{% if leftVar [==|!=|>|>=|<|<=] rightVar %}
    true branch
{% else %}
    false branch
{% endif %}
```

Примеры: [1](testdata/parser/condition.tpl), [2](testdata/parser/conditionNested.tpl), [3](testdata/parser/conditionStr.tpl).

dyntpl не способен распарсить сложные условия, содержащие более одной проверки, пример:
```
{% if user.Id == 0 || user.Finance.Balance == 0 %}You're not able to buy!{% endif %}
```
В будущем эта проблема будет решена, а пока можно сделать несколько вложенных проверок или воспользоваться механизмом
`condition helpers` - это функции со специальной сигнатурой
```go
type CondFn func(ctx *Ctx, args []any) bool
```
, куда можно передать произвольное количество параметров и код этих функций вернёт bool, согласно которому будет выбрана
ветка для исполнения. Эти функции пользовательские и вы можете создать свою и затем зарегестрировать её с помощью функций
```go
func RegisterCondFn(name string, cond CondFn)
func RegisterCondFnNS(namespace, name string, cond CondFn) // namespace version
```

Принцип такой же как у пользовательских модификаторов. Далее condition helper станет доступен в шаблонах по указанному имени:
```
{% if helperName(user.Id, user.Finance.Balance) %}You're not able to buy!{% endif %}
```

В виде отдельного исключения существуют функции `len()` и `cap()`, которые работают аналогично нативным функциям Go.
Результат их выполнения можно сравнивать
```
{% if len(user.Name) > 0 %}...{% endif %}
```
, тогда как обычные пользовательские функции не допускают никакие сравнения.

Для цепочки сравнений dyntpl поддерживает switch оператор, примеры:
* [классический switch](testdata/parser/switch.tpl)
* [switch без условия](testdata/parser/switchNoCondition.tpl)
* [switch без условия и с helper-ми](testdata/parser/switchNoConditionWithHelper.tpl)

switch имеет те же самые ограничения для условий, что и обычное условие. Поэтому необходимо заменять сложные условия
helper-ми.

### Циклы

dyntpl поддерживает оба типа циклов, как и Go:
* циклы со счётчиком, пример `{% for i:=0; i<5; i++ %}...{% endfor %}`
* range-циклы, пример `{% for k, v := range obj.Items %}...{% endfor %}`

Пограничные случаи, такие как `for k < 2000 {...}` или `for ; i < 10 ; {...}` не поддерживаются.

#### Разделители

Если нужно между итерациями вывести какой-то разделитель, то dyntpl имеет специальную инструкцию для циклов, которая
прямо указывает, что нужно выводить:
```
[
  {% for _, a := range user.History separator , %}
    {
      "id": {%q= a.Id %},
      "date": {%q= a.Date %},
      "comment": {%q= a.Note %}
    }
  {% endfor %}
]
```

Этот шаблон будет иметь такой вывод:
The output that will produced:
```json
[
  {"id":1, "date": "2020-01-01", "comment": "success"},
  {"id":2, "date": "2020-01-01", "comment": "failed"},
  {"id":3, "date": "2020-01-01", "comment": "rejected"}
]
```

Разделитель `,` будет выведен после всех итераций (кроме последней) без ручного управления вида `...{% if i>0 %},{% endif %}{% endfor %}`.
Также доступен короткий вариант `sep` вместо `separator`.

