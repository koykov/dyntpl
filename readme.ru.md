# Dynamic templates

Динамическая замена шаблонизатора [quicktemplate](https://github.com/valyala/quicktemplate).

## Ретроспетива

Мы долгое время использовали quicktemplate для создания JSON докементов для обмена данными между микросервисами в
высоконагруженном проекте и qtpl обеспечивал очень хорошую скорость работы. Далее появилась необходимость менять
шаблоны (или создавать новые) на лету. К сожалению, qtpl не поддерживает такую возможность и эта библиотека была
разработана как замена со сравнимой скоростью и динамическими возможностями. Соотвественно она во многом она следует
синтаксису qtpl.

## Принцип работы

Работа с шаблонами поделена на два этапа - парсинг и шаблонизация. Первый этап строит на основе шаблона специальное
дерево (аналог AST), которое затем надо зарегестрировать в регистре шаблонов под каким-то уникальным именем. Этот этап
не предназначен для слишком частого исполнения, т.к. он тяжёлый и дорогой. Второй этап - шаблонизация, напротив предназначен
для использования в хайлоаде. Чтобы передать данные для шаблонизации необходимо добавить переменные в специальную структуру
[Ctx](ctx.go). Каждая переменная характеризуется тремя параметрами:
* уникальное имя
* данные - всё что угодно, что вам необходимо на этапе шаблонизации
* тип-инспектор

Тип инспектор надо рассмотреть подробнее.

В процессе разработки наибольшей проблемой стало получение данных из произвольных структур без использования рефлексии,
поскольку пакет `reflect` слишком медленный и делает много аллоков при любом использовании типа `reflect.Value`.

Для решения этой проблемы был разработан кодогенерирующий фреймворк [inspector](https://github.com/koykov/inspector/blob/master/readme.ru.md).
Он предоставляет примитивные методы для чтения данных из структур, итерирования и тд. без использования рефлексии, причём
делает это быстро. Это достигается посредством использования кодогенерации - inspector для каждой указанной структуры
(или пакета целиком) делает специальные типы, содержащие код специфичный для конкретной структуры. Это не чистая динамика
какую предоставляет пакет `reflect`, но за то работает на порядки [быстрее](https://github.com/koykov/versus/tree/master/inspector2)
и не делает аллокаций.

Пример работы кодогенерации можно посмотреть в пакете [testobj_ins](./testobj_ins), который был сгенерирован на основе
пакета [testobj](./testobj).

## Пример использования

```go
package main

import (
	"bytes"

	"github.com/koykov/dyntpl"
	"path/to/inspector_lib_ins"
	"path/to/test_struct"
)

var (
	// Fill up test struct with data.
	data = &test_struct.Data{
		// ...
	}

	// Template code.
	tplData = []byte(`{"id":"{%=data.Id%}","hist":[{%for _,v:=range data.History separator ,%}"{%=v.Datetime%}"{%endfor%}]}`)
)

func init() {
	// Parse the template and register it.
	tree, _ := dyntpl.Parse(tplData, false)
	dyntpl.RegisterTplKey("tplData", tree)
}

func main() {
	// Prepare output buffer
	buf := bytes.Buffer{}
	// Prepare dyntpl context.
	ctx := dyntpl.AcquireCtx()
	ctx.Set("data", data, inspector_lib_ins.DataInspector{})
	// Execute the template and write result to buf.
	_ = dyntpl.Write(&buf, "tplData", ctx)
	// Release context.
	dyntpl.ReleaseCtx(ctx)
	// buf.Bytes() or buf.String() contains the result.
}
```

Содержимое функции `init` должно выполняться один раз (или периодически, на лету, с обновлением шаблона из какого-то
источника, например БД).

Содержимое функции `main` это пример использования dyntpl в хайлоаде.

## Бенчмарки

См. [bench.md](bench.md) с результатами внутренних бенчмарков. Рекомендуется просмотреть `_test.go` файлы в проекте, они
датут более полное понимание синтаксиса шаблонизатора.

Также доступен [versus/dyntpl](https://github.com/koykov/versus/tree/master/dyntpl) проект со сравнительными бенчмарками
между dyntpl, quicktemplates и нативным шаблонизатором. Как можно увидеть, qtpl в несколько раз быстрее dyntpl, что
неудивительно, т.к. qtpl шаблоны компилируются в нативный Go код. Такова цена наличия динамичности в шаблонизаторе.

## Синтаксис

Как уже упочиналось выше, dyntpl наследует синтаксис у qtpl, но дополнительно имеет множество своих особенностей и
улучшений.

### Вывод данных

Самая базовая инструкция - вывод занчения переменной или поля структуры:
```
Это значение обычной переменной: {%= var0 %}
Это значения поля структуры: {%= obj.Parent.Name %}
```
Инструкция `{%= ... %}` выведет значение как есть, без учёта типа и модификаций.

Для типобезопасного вывода сущуствуют специальные модификаторы. Их надо указывать до инструкции вывода `=`:
* `h` - экранирование HTML.
* `a` - экранирование HTML аттрибута.
* `j` - экранирование JSON.
* `q` - цитирование JSON (quote).
* `J` - экранирование JS (JavaScript).
* `u` - кодирование URL.
* `l` - экранирование ссылок.
* `c` - экранирование CSS.
* `f.<num>` - округление float до количества знаков после запятой, пример: `{%f.3= 3.1415 %}` выведет `3.141`.
* `F.<num>` - округление вверх float до количества знаков после запятой, пример: `{%F.3= 3.1415 %}` выведет `3.142`.

Замечу, что эти модификаторы не применяются по умолчанию и обязанностью пользователя является их оценка и применение в
нужных местах шаблона.

Все модификаторы (кроме `f` и `F`) допускают множественное использование - `{%jj= ... %}`, `{%uu= ... %}`, `{%uuu= ... %}`, ...

Например, такая инструкция `{%uu= someUrl %}` выведет дважды экранированное значение `someUrl`.

Также модификаторы вывода можно комбинировать друг с другов в любых комбинациях (`{%Ja= var1 %}`, `{%jachh= var1 %}`, ...).
Модификаторы будут применять последовательно и каждый следующий модификатор получит на вход результат работы предыдущего.

Инструкция вывода позволяет указать префикс и/или суффикс (пример `{%= var0 prefix foo suffix bar %}`). Префикс/суффикс
будет выведен только если выводимое значение не пустое. Также доступны сокращённые варианты `pfx` и `sfx`.

